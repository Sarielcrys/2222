clc;close all;clear;								%清空还原

A = zeros(128);									%生成一个全0矩阵

A(50:55,42:82) = 1; 								%生成“横”
A(32:50,60:65) = 1; 								%生成“竖”
 
A(36:40,47:51) = 1; 								%生成“光”字左上角的点
A(37:41,48:52) = 1;
A(38:42,49:53) = 1;
A(39:43,50:54) = 1;
A(40:44,51:55) = 1;
 
A(36:40,74:78) = 1; 								%生成“光”字右上角的点
A(37:41,73:77) = 1;
A(38:42,72:76) = 1;
A(39:43,71:75) = 1;
A(40:44,70:74) = 1;

A(56:62,54:59) = 1; 								%生成“撇”
A(63:64,53:58) = 1;
A(65:66,51:57) = 1;
A(67:68,49:55) = 1;
A(69:70,47:53) = 1;
A(71:72,45:51) = 1; 
A(73:74,43:49) = 1;

A(55:73,66:71) = 1;								%生成“竖弯钩”
A(74,67:72) = 1;
A(69:74,71:82) = 1;
A(65:74,80:84) = 1;
A(74,84) = 0;
A(73,84) = 0;
A(74,83) = 0;

figure('name','原始图像');imshow(A,[]);  			%显示图像
Am = abs(A);									%取振幅
Ph = angle(A);									%取相位
disp(Am);										%显示振幅信息
disp(Ph);										%显示相位信息
s = 11;		%设置编码单元大小s，考虑全息图大小与方便计算所以取为11
cgh = zeros(128*s);								%生成全0计算编码矩阵
th = max(max(abs(A)));							%计算最大振幅值
qq = th/1.2;										%截断最大振幅值
Am(Am>qq) = qq;								%将阈值以上的振幅降低到阈值
q = 1:s;											%生成单元格离散序列
w = (s+1)/2;										%计算中心坐标

for m = 1:128;									%编码开始，遍历各行
for n = 1:128;								%遍历各列
h = round(Am(m,n)/qq*(w-1)-0.5);		%归一化振幅并量化
md = zeros(s); 							%初始化单元格
if h>0;									%开始对正数振幅单元编码 
td = ones(h*2+1,3);					%生成矩形透明孔
		Pm = round(Ph(m,n)/3*pi);			%对相位编码
		kz = Pm+w;							%计算透明孔的列位置
md(w-h:w+h,kz-1:kz+1) = td;			%按列位置赋值
end
cgh((m-1)*s+q,(n-1)*s+q) = md;		%把计算得到的单元孔放到对应位置处
end
end												%结束编码

figure('name','编码后的像面全息图');imshow(cgh,[]);  %显示编码后的像面全息图
Re = fft2(cgh);									%快速傅里叶变换得到频谱面
Re = fftshift(Re); 								%进行频谱移动，将0级移到中央
figure('name','衍射面频谱图');imshow(abs(Re),[])	%显示图像
M = size(cgh);									%计算图像宽度记为M
sigma = 36;										%设置高斯滤波器的方差
H = fspecial('gaussian', M, sigma);					%设置高斯滤波器
Re = H.*Re;  									%进行滤波
figure('name','滤波后的频谱图');imshow(abs(Re),[]); %显示滤波后的频谱图
Re = ifft2(Re);									%快速傅里叶逆变换
figure('name','再现图像');imshow(abs(Re),[]);		%显示再现图像
